<?php
/**
 * Provides email_validator_check($mail)
 *
 * Authors: Artful Robot <forums@artfulrobot.com>,
 * 	        Daniel Bonniot <bonniot@users.sourceforge.net>
 * License:   GNU GPL v2 or later
 */

// Drupal hooks
//function email_validator_menu()/*{{{*/
/**
 * Implements hook_menu
 *
 */
function email_validator_menu()
{
    $items['admin/email-validator'] = array(
            'page callback' => 'drupal_get_form',
            'page arguments'  => array('email_validator_admin_form'),
            'access arguments'  => array('administer email_validator'),
            'type' => MENU_CALLBACK,
            );
    return $items;
}/*}}}*/
function email_validator_permission()/*{{{*/
{
	return array(
			'administer email_validator' => array(
				'title' => t('Administer Email Validator'),
				'description' => t('Set return path for SMTP conversations'),
				),
			);
}/*}}}*/
//function email_validator_schema()/*{{{*/
/**
 * Implements hook_schema
 */
function email_validator_schema()
{
    $schema = array();
    $schema['email_validator_cache'] = array(
        'description' => 'Holds recent SMTP lookup results',
        'fields' => array(
            'id' => array(
                'description' => 'primary key',
                'type' => 'serial',
                'unsigned' => true,
                'not null' => true,
                ),
            'ip' => array(
                'description' => 'Client IP address',
                'type' => 'varchar',
                'length' => 15, // nnn.nnn.nnn.nnn
                'not null' => true,
                'default' => '',
                ),
            'email' => array(
                'description' => 'The email address looked up',
                'type' => 'varchar',
                'length' => 200,
                'not null' => true,
                'default' => '',
                ),
            'when' => array(
                'description' => 'Unix time of lookup',
                'type' => 'int',
                'unsigned' => true,
                'not null' => true,
                'default' => 0,
                ),
            'result' => array(
                'description' => 'Successful SMTP?',
                'type' => 'int',
                'size' => 'tiny',
                'not null' => true,
                'unsigned' => true,
                'default' => 0,
                ),
            ),
        'primary key' => array( 'id' ),
        'indexes' => array(
            'i_when' => array('when'),
            'i_email' => array('email'),
            'i_ip' => array('ip'),
            ),
    );

    return $schema;
}/*}}}*/

// Forms
//function email_validator_admin_form()/*{{{*/
/**
 * Admin form
 */
function email_validator_admin_form()
{
    drupal_set_title("Configure Email Validator API");
    $form = array(
        'email_validator_returnpath' => array(
            '#type' => 'textfield',
            '#title' => t('Email address to use for return path in checks. Should be valid.'),
            '#default_value' => variable_get('email_validator_returnpath',
                variable_get('site_mail', ini_get('sendmail_from'))),
            ),
        );
    return system_settings_form($form);
}/*}}}*/

// Main API function
// function email_validator_check($mail) {{{
/**
 * This function a modified version of the email_validator module's:
 * 	Verifies thoroughly that email addresses are correctly entered
 * 	Copyright: Daniel Bonniot <bonniot@users.sourceforge.net>
 * 	License:   GNU GPL v2 or later
 *
 * @return error string, or null (no error)
 */
function email_validator_check($mail) {

  if (!valid_email_address($mail)) {
    // The address is syntactically incorrect.
    return t('Email address %mail is invalid', array('%mail'=>$mail));
  }

  $host = drupal_substr(strchr($mail, '@'), 1);

  // first check if we've looked this up recently.
  $result = db_query('SELECT result FROM {email_validator_cache} e '
            .'WHERE e.email = :email AND e.{when} > :when',
         array(
            ':email' => $mail,
            ':when' => time() - 60*60*24, // last day
         ))->fetchField();
  if ($result !== false) {
    return email_validator_code_translate($result, $mail, $host);
  }

  // Let's see if we can find anything about this host in the DNS.
  if (!checkdnsrr($host, 'ANY')) {
    return email_validator_result($mail,$host, 2);
  }

  // are we banned?
  if (email_validator_flood()) {
    return t('Sorry, there have been too many invalid email addresses tried from your IP address.');
  }

  // What SMTP servers should we contact?
  $mx_hosts = array();
  if (!getmxrr($host, $mx_hosts)) {
    // When there is no MX record, the host itself should be used.
    $mx_hosts[] = $host;
  }

  // Try to connect to one SMTP server.
  foreach ($mx_hosts as $smtp) {

    $connect = @fsockopen($smtp, 25, $errno, $errstr, 15);

    if (!$connect) {
      continue;
    }

    if (preg_match("/^220/", $out = fgets($connect, 1024))) {
      // OK, we have a SMTP connection.
      break;
    }
    else {
      // The SMTP server probably does not like us
      // (dynamic/residential IP for aol.com for instance)
      // Be on the safe side and accept the address, at least it has a valid
      // domain part...
      return email_validator_result($mail,$host, 1);
    }
  }

  if (!$connect) {
    return email_validator_result($mail,$host, 3);
  }

  $from = variable_get('email_validator_returnpath',
                variable_get('site_mail', ini_get('sendmail_from')));
  // Extract the <...> part, if there is one.
  if (preg_match('/\<(.*)\>/', $from, $match) > 0) {
    $from = $match[1];
  }

  // Should be good enough for RFC compliant SMTP servers.
  $localhost = $_SERVER["HTTP_HOST"];
  if (!$localhost) {
    $localhost = 'localhost';
  }

  fputs($connect, "HELO $localhost\r\n");
  $out = fgets($connect, 1024);
  fputs($connect, "MAIL FROM: <$from>\r\n");
  $from = fgets($connect, 1024);
  fputs($connect, "RCPT TO: <{$mail}>\r\n");
  $to = fgets($connect, 1024);
  fputs($connect, "QUIT\r\n");
  fclose($connect);

  if (!preg_match("/^250/", $from)) {
    // Again, something went wrong before we could really test the address.
    // Be on the safe side and accept it.
    watchdog('email_validator', "Could not verify email address at host $host: $from (but accepted from user's POV)");
    return email_validator_result($mail,$host, 5);
  }

  if (
      // This server does not like us (noos.fr behaves like this for instance).
      preg_match("/(Client host|Helo command) rejected/", $to) ||
      // Any 4xx error also means we couldn't really check except 450, which is
      // explcitely a non-existing mailbox: 450 = "Requested mail action not
      // taken: mailbox unavailable".
      preg_match("/^4/", $to) && !preg_match("/^450/", $to)) {
      // In those cases, accept the email, but log a warning.
      watchdog('email_validator', "Could not verify email address at host $host: $to (but accepted from user's POV)");
      return email_validator_result($mail,$host, 6);
  }

  if (!preg_match("/^250/", $to)) {
    watchdog('email_validator', "Rejected email address: $mail. Reason: $to");
    return email_validator_result($mail,$host, 4);
  }

  // Everything is OK, so record success.
  return email_validator_result($mail,$host, 0);
}//}}}

// Utility functions
// function email_validator_code_translate($code, $mail) {{{
/**
 * @return error string, or null (no error)
 */
function email_validator_code_translate($code, $mail, $host) {

  switch ($code) {
    case 0: // perfecto
    case 5: // Something went wrong in initial SMTP chat. Allow it.
    case 6: // We were unable to obtain a definite YES, or NO. Allow it.
        return null;
    case 1:
        return t('The email provider %host is not allowing this website to send it email.', array('%host'=>$host));
    case 2:
        return t('Email host %host invalid, please correct.', array('%host' => "$host"));
    case 3:
        return t('Email host %host is not accepting email.', array('%host' => "$host"));
    case 4:
        return t('The email server for %mail is not accepting our email. Could be wrong email, full inbox, or a blocking policy.', array('%mail' => "$mail"));
    default:
        return;
  }
}//}}}
// function email_validator_result($code, $mail) {{{
/**
 * Store result
 */
function email_validator_result($mail, $host, $code) {

  db_insert('email_validator_cache')
    ->fields( array(
        'ip' => $_SERVER['REMOTE_ADDR'],
        'email' => $mail,
        '{email_validator_cache}.when' => time(),
        'result' => $code,
        ))
    ->execute();

    return email_validator_code_translate($code, $mail, $host);

}//}}}
// function email_validator_flood() {{{
/**
 * Detects flood
 *
 * @return bool true for flood detected
 */
function email_validator_flood() {

  $flood = db_query('SELECT COUNT(*) FROM email_validator_cache e '
        . 'WHERE ip = :ip AND e.when > :when',
    array(
        ':ip' => $_SERVER['REMOTE_ADDR'],
        ':when' => time() - 1800, // 30 mins.
    ))
    ->fetchField();
  if ($flood>2) {
     // flood detected
     watchdog('email_validator', "IP $_SERVER[REMOTE_ADDR] exceeded flood limit");
     return true;
  }
 return false;
}//}}}
