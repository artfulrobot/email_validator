<?php
/**
 * Provides email_validator_check($mail)
 *
 * Authors: Artful Robot <forums@artfulrobot.com>,
 * 	        Daniel Bonniot <bonniot@users.sourceforge.net>
 * License:   GNU GPL v2 or later
 */

// Drupal hooks

/**
 * Implements hook_menu
 *
 */
function email_validator_menu()
{
  $items['admin/config/email-validator'] = array(
    'title' => 'Configure Email Validator',
    'page callback' => 'drupal_get_form',
    'page arguments'  => array('email_validator_admin_form'),
    'access arguments'  => array('administer email_validator'),
  );
  $items['admin/reports/email-validator'] = array(
    'title' => 'Email Validator',
    'page callback' => 'drupal_get_form',
    'page arguments'  => array('email_validator_debug_form'),
    'access arguments'  => array('administer email_validator'),
  );
  return $items;
}
function email_validator_permission()
{
	return array(
			'administer email_validator' => array(
				'title' => t('Administer Email Validator'),
				'description' => t('Set return path for SMTP conversations'),
				),
			);
}

/**
 * Implements hook_schema
 */
function email_validator_schema()
{
    $schema = array();
    $schema['email_validator_cache'] = array(
        'description' => 'Holds recent SMTP lookup results',
        'fields' => array(
            'id' => array(
                'description' => 'primary key',
                'type' => 'serial',
                'unsigned' => true,
                'not null' => true,
                ),
            'ip' => array(
                'description' => 'Client IP address',
                'type' => 'varchar',
                'length' => 15, // nnn.nnn.nnn.nnn
                'not null' => true,
                'default' => '',
                ),
            'email' => array(
                'description' => 'The email address looked up',
                'type' => 'varchar',
                'length' => 200,
                'not null' => true,
                'default' => '',
                ),
            'when' => array(
                'description' => 'Unix time of lookup',
                'type' => 'int',
                'unsigned' => true,
                'not null' => true,
                'default' => 0,
                ),
            'result' => array(
                'description' => 'Successful SMTP?',
                'type' => 'int',
                'size' => 'tiny',
                'not null' => true,
                'unsigned' => true,
                'default' => 0,
                ),
            ),
        'primary key' => array( 'id' ),
        'indexes' => array(
            'i_when' => array('when'),
            'i_email' => array('email'),
            'i_ip' => array('ip'),
            ),
    );

    return $schema;
}

// Forms

/**
 * Admin form
 */
function email_validator_admin_form()
{
    drupal_set_title("Configure Email Validator API");
    $form = array(
        'email_validator_returnpath' => array(
            '#type' => 'textfield',
            '#title' => t('Email address to use for return path in checks. Should be valid.'),
            '#default_value' => variable_get('email_validator_returnpath',
                variable_get('site_mail', ini_get('sendmail_from'))),
            ),
        'email_validator_flood_today' => [
          '#type' => 'textfield',
          '#title' => t('How many failed attempts in one day before we ban the IP address? Suggestion: 3'),
          '#default_value' => variable_get('email_validator_flood_today',3),
        ],
        'email_validator_flood_this_month' => [
          '#type' => 'textfield',
          '#title' => t('How many failed attempts in one month before we ban the IP address? Suggestion: 10'),
          '#default_value' => variable_get('email_validator_flood_month',10),
        ],
    );
    return system_settings_form($form);
}


/**
 * This function a modified version of the email_validator module's:
 * 	Verifies thoroughly that email addresses are correctly entered
 * 	Copyright: Daniel Bonniot <bonniot@users.sourceforge.net>
 * 	License:   GNU GPL v2 or later
 *
 * @return error string, or null (no error)
 */
function email_validator_check($mail, &$debug_log=null, $use_cache=TRUE) {
  $debug_log = array();

  if (!valid_email_address($mail)) {
    // The address is syntactically incorrect.
    $debug_log[] = "$mail failed valid_email_address test";
    $debug_log[] = $msg = t('Email address %mail is invalid', array('%mail'=>$mail));
    return $msg;
  }

  $host = drupal_substr(strchr($mail, '@'), 1);

  if ($use_cache) {
    // first check if we've looked this up recently.
    $result = db_query('SELECT result FROM {email_validator_cache} e '
              .'WHERE e.email = :email AND e.{when} > :when',
           array(
              ':email' => $mail,
              ':when' => time() - 60*60*24, // last day
           ))->fetchField();
    if ($result !== false) {
      $debug_log[] = "Returning from cache: result $result";
      $debug_log[] = $msg = email_validator_code_translate($result, $mail, $host);
      return $msg;
    }
    $debug_log[] = "Not in cache";
  }
  else {
    $debug_log[] = "Cache not consulted";
  }

  // Let's see if we can find anything about this host in the DNS.
  if (!checkdnsrr($host, 'ANY')) {
    $debug_log[] = "checkdnsrr ANY failed for host '$host'";
    $debug_log[] = $msg = email_validator_result($mail,$host, 2);
    return $msg;
  }
  $debug_log[] = "checkdnsrr ANY success";

  // are we banned?
  if (email_validator_flood($mail)) {
    $debug_log[] = $msg = t('Sorry, there have been too many invalid email addresses tried from your IP address.');
    return $msg;
  }

  // What SMTP servers should we contact?
  $mx_hosts = array();
  if (!getmxrr($host, $mx_hosts)) {
    $debug_log[] = "getmxrr failed for '$host' - will use '$host'";
    // When there is no MX record, the host itself should be used.
    $mx_hosts[] = $host;
  }
  $debug_log[] = "MX hosts found: " . implode(", ", $mx_hosts);

  // Some of these may be multiple IPs - we'd need to test them all. Make a unique list.
  $mx_ips = array();
  foreach ($mx_hosts as $hostname) {
    foreach (gethostbynamel($hostname) as $ip) {
      $mx_ips[$ip] = $hostname;
  } }

  // Try to connect to one SMTP server.
  foreach ($mx_ips as $smtp=>$hostname) {
    $debug_log[] = "Trying MX $smtp for $hostname";

    $connect = @fsockopen($smtp, 25, $errno, $errstr, 15);

    if (!$connect) {
      $debug_log[] = "...failed to connect to $smtp<-$hostname<-$host  (error: $errno: $errstr)";
      continue;
    }

    // Connected, read all the info the servers sends.
    // The end to this happens when a space is on the 4th character!
    $rcv ='';
    do {
      $_ = fgets($connect, 1024);
      $rcv .= trim($_) . "\n"; // normalise line endings.
    } while (isset($_[3]) && $_[3] != ' ');

    if (preg_match("/^220 /m", $rcv)) {
      $debug_log[] = "...successful connection, will continue with this MX";
      // OK, we have a SMTP connection.
      break;
    }
    else {
      $debug_log[] = "...connection was not allowed: $rcv";
      // The SMTP server probably does not like us
      // (dynamic/residential IP for aol.com for instance)
      // Be on the safe side and accept the address, at least it has a valid
      // domain part...
      // $debug_log[] = $msg = email_validator_result($mail,$host, 1);
      // return $msg;
      $connect = FALSE;
    }
  }

  if (!$connect) {
    $debug_log[] = "Failed to connect to any MX for $mail";
    $debug_log[] = $msg = email_validator_result($mail,$host, 3);
    return $msg;
  }

  $from = variable_get('email_validator_returnpath',
                variable_get('site_mail', ini_get('sendmail_from')));
  // Extract the <...> part, if there is one.
  if (preg_match('/\<(.*)\>/', $from, $match) > 0) {
    $from = $match[1];
  }
  $debug_log[] = "Using <$from> for returnpath";

  // Should be good enough for RFC compliant SMTP servers.
  $localhost = $_SERVER["HTTP_HOST"];
  if (!$localhost) {
    $localhost = 'localhost';
  }
  $debug_log[] = "Using $localhost for HELO";

  $debug_log[] = "»HELO $localhost";
  fputs($connect, "HELO $localhost\r\n");
  $out = fgets($connect, 1024);
  $debug_log[] = "«" . htmlspecialchars(trim($out));
  $debug_log[] = "»MAIL FROM: <$from>";
  fputs($connect, "MAIL FROM: <$from>\r\n");

  // We look out for any 250 response and consider that OK.
  $from = fgets($connect, 1024);
  $debug_log[] = "«" . htmlspecialchars(trim($from));
  $from_response_had_250_success = preg_match('/^250/', $from);

  $debug_log[] = "»RCPT TO: <{$mail}>";
  fputs($connect, "RCPT TO: <{$mail}>\r\n");
  $to = fgets($connect, 1024);
  $debug_log[] = "«" . htmlspecialchars(trim($to));
  $debug_log[] = "»QUIT";
  fputs($connect, "QUIT\r\n");
  fclose($connect);

  if (!$from_response_had_250_success)  {
    // Again, something went wrong before we could really test the address.
    // Be on the safe side and accept it.
    $from = implode("<br />",$from);
    watchdog('email_validator', "Could not verify email address at host $host: $from (but accepted from user's POV)");
    $debug_log[] = "MAIL FROM did not give success (250) code. (we still allow this) Instead got<pre>$from</pre>";
    $from = htmlspecialchars($from);
    $debug_log[] = $msg = email_validator_result($mail,$host, 5);
    return $msg;
  }

  if (preg_match("/^4/", $to)
      || preg_match("/(Client host|Helo command) rejected/", $to)) {
      // Any 4xx error also means we couldn't really check, a mail *might* get through
      // (e.g. greylist, or mailbox full at mo).
      // This server does not like us (noos.fr behaves like this for instance).

    // look out for greylisting
    if (preg_match('/gr[ea]y ?list/i', $to)) {
      $debug_log[] = "Greylisted, should be fine. Got: $to";
      watchdog('email_validator', "Greylisting in operation at $host: $to accepted by validator.");
      $debug_log[] = $msg = email_validator_result($mail,$host, 6);
      return $msg;
    }

    // In those cases, accept the email, but log a warning.
    $debug_log[] = "MAIL TO failed. (still accept). Got: $to";
    watchdog('email_validator', "Could not verify email address at host $host: $to (but accepted from user's POV)");
    $debug_log[] = $msg = email_validator_result($mail,$host, 6);
    return $msg;
  }

  if (!preg_match("/^250/", $to)) {
    watchdog('email_validator', "Rejected email address: $mail. Reason: $to");
    $debug_log[] = "MAIL TO did not give success (250) code. Instead got $to";
    $debug_log[] = $msg = email_validator_result($mail,$host, 4);
    return $msg;
  }

  // Everything is OK, so record success.
  $debug_log[] = "SUCCESS.";
  $debug_log[] = $msg = email_validator_result($mail,$host, 0);
  return $msg;
}


/**
 * Debug form
 */
function email_validator_debug_form() {
  drupal_set_title("Email Validator Test email address");
  $form = array(
    'test_email' => array(
      '#type' => 'textfield',
      '#title' => t('Enter email address to test. No mail will actually be sent. You can also enter a like match e.g. %@foo.com if you want to just do an IP lookup'),
      '#default_value' => '',
    ),
    'cache' => array(
      '#type' => 'checkbox',
      '#title' => 'Do not use cache',
      '#default_value' => 1,
    ),
    'cache_clear' => array(
      '#type' => 'textfield',
      '#title' => 'Clear cache for emails with this substring. Use * for full cache clear(!)',
      '#default_value' => '',
    ),
    'test_ip' => array(
      '#type' => 'textfield',
      '#description' => "Nb. your IP address is $_SERVER[REMOTE_ADDR]",
      '#title' => 'Check a certain IP address',
      '#default_value' => '',
    ),
    'submit' => array(
      '#type' => 'submit',
      '#value' => 'Test',
    ),
  );
  return $form;
}
/**
 * Check the given email
 */
function email_validator_debug_form_validate($form, &$form_state) {

}
/**
 * Check the given email
 */
function email_validator_debug_form_submit($form, &$form_state) {
  $form_state['redirect'] = false;

  $match = trim($form_state['values']['cache_clear']);
  if ($match) {
    // we need to clear the cache.
    $del = db_delete('email_validator_cache');

    if ($match != '*') {
      $del->condition('email', "%$match%", "LIKE");
    }
    $del->execute();
    drupal_set_message("Cleared cache for all emails matching " . htmlspecialchars($match));
  }

  $ips = [];
  if ($form_state['values']['test_email']) {
    // We have an email
    $mail = $form_state['values']['test_email'];
    $host = drupal_substr(strchr($mail, '@'), 1);

    // First, run the tests.
    if (strpos($form_state['values']['test_email'], '%')===FALSE) {
      $result = email_validator_check($form_state['values']['test_email'], $log, ! (bool) $form_state['values']['cache']);
      $log = "<pre>" . htmlspecialchars(implode("\n", $log)) . "</pre>";
      if ($result) {
        form_set_error("test_email", $log);
      }
      else {
        drupal_set_message("Accepted.<br />$log");
      }
    }

    // perform ip analysis.
    // Look up ip(s) matching the given address, then add a report for each IP.
    $result = db_query('SELECT * FROM {email_validator_cache} e WHERE e.email LIKE(:email)',
      [ ':email' => $form_state['values']['test_email'] ]);

    $table = ['header' => ['Date', 'IP', 'Email', 'Result'], 'rows' => []];
    while ($row = $result->fetchAssoc()) {
      $ips[$row['ip']] = 1;
      $line = email_validator_code_translate($row['result'], $mail, $host);
      if ($line === null) {
        $line = "OK (code $row[result])";
      }
      $table['rows'][] = [ date('j M Y H:i:s', $row['when']), $row['ip'], $row['email'], $line ];
    }
    $ips = array_keys($ips);
    $table=theme('table', $table);
    drupal_set_message("Cache table for " . $form_state['values']['test_email'] . ":\n" . $table);
  }

  if (!empty($form_state['values']['test_ip'])) {
    $ips [] = $form_state['values']['test_ip'];
  }

  if ($ips) {
    $too_many_today = (int) variable_get('email_validator_flood_today',3);
    $too_many_this_month = (int) variable_get('email_validator_flood_month',10);
    $table = ['header' => ['IP address', "Failures today (allowed $too_many_today)", "Failures last month (allowed $too_many_this_month)", 'Lookups last month'], 'rows'=> []];
    $failed_attempts = 'e.result IN (1,2,3,4)';
    foreach ($ips as $ip) {

      $flood = db_query(
        "SELECT SUM(e.when > :in_last_day AND $failed_attempts ) AS failures_today,
        SUM($failed_attempts) AS failures_last_month,
        COUNT(ip) AS lookups_last_month
        FROM email_validator_cache e
        WHERE ip = :ip AND e.when > :in_last_month",
        array(
          ':ip' => $ip,
          ':in_last_day' => time() - 60*60*24, // 1 day
          ':in_last_month' => time() - 60*60*24*30, // 1 month(ish)
        ))->fetchAssoc();

      $table['rows'][] = [$ip, (int)$flood['failures_today'], (int)$flood['failures_last_month'], (int)$flood['lookups_last_month'] ];
    }
    $table = "<h3>IP flood report</h3>" . theme('table', $table);
    drupal_set_message($table);

  }
}


// Utility functions

/**
 * @return error string, or null (no error)
 */
function email_validator_code_translate($code, $mail, $host) {

  switch ($code) {
    case 0: // perfecto
    case 5: // Something went wrong in initial SMTP chat. Allow it.
    case 6: // We were unable to obtain a definite YES, or NO. Allow it.
        return null;
    case 1:
        return t('The email provider %host is not allowing this website to send it email.', array('%host'=>$host));
    case 2:
        return t('Email host %host invalid, please correct.', array('%host' => "$host"));
    case 3:
        return t('Email host %host is not accepting email.', array('%host' => "$host"));
    case 4:
        return t('The email server for %mail is not accepting our email. Could be wrong email, full inbox, or a blocking policy.', array('%mail' => "$mail"));
    default:
        return;
  }
}

/**
 * Store result
 */
function email_validator_result($mail, $host, $code) {

  db_insert('email_validator_cache')
    ->fields( array(
        'ip' => $_SERVER['REMOTE_ADDR'],
        'email' => $mail,
        '{email_validator_cache}.when' => time(),
        'result' => $code,
        ))
    ->execute();

    return email_validator_code_translate($code, $mail, $host);

}

/**
 * Detects flood, currently configged at 3/day max.
 *
 * Behaviours to catch
 *
 * 1. fast-paced abuse, lots of tests quickly
 * 2. timed abuse, e.g. 4/day at regular intervals
 * 3. history of abuse in last month.
 *
 * (1, 2) are dealt with together: allowed 3 failed attempts in one day
 * (3) is done as over 10 failed attempts in the last month.
 *
 * @return bool true for flood detected
 */
function email_validator_flood($mail) {

  $failed_attempts = 'e.result IN (1,2,3,4)';
  $ok_attempts = 'e.result IN (0,5,6)';
  $too_many_today = (int) variable_get('email_validator_flood_today',3);
  $too_many_this_month = (int) variable_get('email_validator_flood_month',10);
  $flood = db_query(
        "SELECT SUM(e.when > :in_last_day AND $failed_attempts )>$too_many_today OR
                SUM($failed_attempts) > $too_many_this_month
                AS deny
        FROM email_validator_cache e
        WHERE ip = :ip AND e.when > :in_last_month",
    array(
        ':ip' => $_SERVER['REMOTE_ADDR'],
        ':in_last_day' => time() - 60*60*24, // 1 day
        ':in_last_month' => time() - 60*60*24*30, // 1 month(ish)
    ))
    ->fetchField();
  if ($flood=="1") {
     // flood detected
     watchdog('email_validator', "IP @ip exceeded flood limit. @mail denied.",
        array('@ip'=>$_SERVER['REMOTE_ADDR'],
              '@mail' => $mail ));
     return true;
  }
 return false;
}
